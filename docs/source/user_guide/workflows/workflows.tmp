.. _tut-ref-to-yambo-tutorial:

Yambo Workflows Tutorial
========================

.. toctree::
   :maxdepth: 2

The following shows how to use the workflows provided by the  `aiida yambo` plugin.


YamboRestartWf
--------------

The `YamboRestartWf` provides the ability to run yambo GW calculations, starting from completed
NSCF PW calculations.  It can restart the calculations should they fail from several types of
causes including:

  1.) Queue time exhaustion
  2.) Memory related failures (the workflow will adjust the parallelism before resubmitting, by reducing MPI in favour of threading)

Example usage:

.. include:: ../../../../examples/test_wf/yambo_restart.py
   :literal:


YamboWorkflow
--------------

The `YamboWorkflow`  provides the functionality to run GW calculation from the PW step, passing in all the required
parameters for both the  KS DFT step with PW and the subsequent GW step. It uses the PwBaseWorkchain from `aiida-quantumespresso`
as a subworkflow to perform the first  DFT part and the `YamboRestartWf`  for the GW part.

Example usage.

.. include:: ../../../../examples/test_wf/yambo_wfl.py
   :literal:


YamboConvergence
----------------------------

The `YamboConvergence` provides the functionality to run G0W0 calculations over several paramaeters,
and it can be used (for now) to perform multi-parameter investigation of the quasiparticle corrections.
It is possible to accomplish automatic convergence by iteration over one or more parameter in a serial way,
or to explore a provided 2-dimensional space of parameters, in order to perform a successive extrapolation of the results(these can be useful
in particular to obtain competitive results in molecular systems).
Let's see the case of automatic convergence over an arbitrary number of parameters ("wfl_type": 1D_convergence):

Example usage:

.. include:: ../../../../examples/test_wf/yambo_conv.py
   :literal:

As we notice, we have to provide a list of dictionaries, each representing a given step of the investigation: we have to specify the variables, the increment (delta) that has to be done
at each step, the convergence threshold which determines the convergence or not, what we want to converge(gap or single-levels), where we want to observe these results in terms of bands and k-points (quasiparticle corrections
are ordered first by k-points, and then by bands: [[k1_b1,k1_b2],[k2_b1,k2_b2]] etc.).
When we converge k-points, we need to specify the 'starting_k_distance': these because the creation and variation of the k-point mesh is
managed using the 'set_kpoints_mesh_from_density' function.

The complete workflow will return the results of the convergence iterations, as well as a final converged set of parameters.
The data can be plotted to produce the following:

.. image:: ../../images/Conv_tio2.png

Let's see the case of 2-dimensional space exploration:

Example usage:

.. include:: ../../../../examples/test_wf/yambo_2d.py
   :literal:
